##
## 73 subjects, 2 variables:
##  Year(x[i])
##  Number of Calls (y[i], in tens of millions)
##
## http://www.uni-koeln.de/themen/statistik/data/rousseeuw/
## Datasets used in Robust Regression and Outlier Detection (Rousseeuw and Leroy, 1986).
## Provided on-line at the University of Cologne.
library(xji3ST790)
x <- c(50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
69, 70, 71, 72, 73)
y <- c(0.44, 0.47, 0.47, 0.59, 0.66, 0.73, 0.81, 0.88, 1.06, 1.20, 1.35, 1.49, 1.61,
2.12, 11.90, 12.40, 14.20, 15.90, 18.20, 21.20, 4.30, 2.40, 2.70, 2.90)
epsilon <- 0.25
X <- cbind(rep(1, length(x)), x)
fit.smLAD <- smLAD(X, y)
fit.lm <- lm(y ~ X)
fitted.lm <- fit.lm$fitted.values
fitted.smLAD <- X %*% fit.smLAD$beta
# Now plot the two fitted lines and data
plot(x, y, type = "l", col = "blue", main = "Step 2 plot")
lines(x, fitted.lm, lty = 2, col = "green")
lines(x, fitted.smLAD, lty = 3, col = "red")
legend(x[1], 20,legend = c("Data", "Least Sqaure", "smLAD"),
lty = c(1, 2, 3), col = c("blue", "green", "red"))
# Chunk 3
plot(fit.smLAD$fx.values, xlab = "k", ylab = "fx_smLAD", main = "Step 3 plot")
# Chunk 4
rm(list=ls())  # clean up workspace
#' Compute Newton Step (Naive) for logistic ridge regression
#'
#' @param X Design matrix
#' @param y Binary response vector
#' @param beta Current regression vector estimate
#' @param g Gradient vector
#' @param lambda Regularization parameter
newton_step_naive <- function(X, y, beta, g, lambda) {
X <- as.matrix(X)
X.beta <- X %*% beta
exp.X.beta <- exp(X.beta)
W <- exp.X.beta / (exp.X.beta + 1)^2
A <- lambda*diag(rep(dim(X)[2]))+crossprod(X, as.vector(W) * X)
L.t <- chol(A)
Lt.x <- forwardsolve(t(L.t), g)
delta.beta.nt <- backsolve(L.t, Lt.x)
return(delta.beta.nt)
}
# Chunk 5
#' Compute Newton Step (Sherman-Morrison-Woodbury) for logistic ridge regression
#'
#' @param X Design matrix
#' @param y Binary response vector
#' @param beta Current regression vector estimate
#' @param g Gradient vector
#' @param lambda Regularization parameter
newton_step_smw <- function(X, y, beta, g, lambda) {
X <- as.matrix(X)
X.beta <- X %*% beta
exp.X.beta <- exp(X.beta)
W.sqrt <- sqrt(exp.X.beta) / (exp.X.beta + 1)
V <- as.vector(W.sqrt) * X
C <- diag(rep(dim(X)[1])) + tcrossprod(V, V) / lambda
B.inv <- diag(rep(dim(X)[2])) / lambda - 1 / lambda^2 * crossprod(V, solve(C, V))
return(B.inv %*% g)
}
# Chunk 6
#' Backtracking for steepest descent
#'
#' @param fx handle to function that returns objective function values
#' @param x current parameter estimate
#' @param t current step-size
#' @param df the value of the gradient of objective function evaluated at the current x
#' @param d descent direction vector
#' @param alpha the backtracking parameter
#' @param beta the decrementing multiplier
backtrack_descent <- function(fx, x, t, df, d, alpha=0.5, beta=0.9, max.iter = 1e3) {
old.func.value <- fx(x)
tk <- t
for (num.iter in 1:max.iter){
new.x <- x - tk * d
new.func.value <- fx(new.x)
if(new.func.value < old.func.value -alpha * tk * crossprod(df, d)){
return(tk)
}else{
tk <- beta * tk
}
}
warning("Backtrack step search reaches max iterations!
Try increase max_iteration for backtrack function.")
return(tk)
}
# Chunk 7
#' Damped Newton's Method for Fitting Ridge Logistic Regression
#'
#' @param y Binary response
#' @param X Design matrix
#' @param beta Initial regression coefficient vector
#' @param lambda regularization parameter
#' @param max_iter maximum number of iterations
#' @param tol convergence tolerance
logistic_ridge_newton <- function(X, y, beta, lambda=0, max_iter=1e2, tol=1e-3, method = "naive") {
fx <- partial(fx_logistic, y = y, X = X)
df <- partial(gradf_logistic, y = y, X = X)
old.beta <- beta
g <- df(old.beta)
t <- 4.0 / norm(X, type = "2") ^ 2
if(method == "smw"){
newton_step_handle = newton_step_smw
}
else{
newton_step_handle = newton_step_naive
}
for (num.iter in 1:max_iter){
delta.x.nt <- newton_step_handle(X, y, old.beta, g, lambda)
decrement <- crossprod(g, delta.x.nt)
if (0.5 * decrement < tol){
return(list(beta = old.beta, num.iter = num.iter))
}else{
tk <- backtrack_descent(fx, old.beta, t, g, delta.x.nt, 0.5, 0.9)
old.beta <- old.beta - tk * delta.x.nt
}
}
warning("Max iterations reached!")
return(list(beta = old.beta, num.iter = num.iter))
}
# Chunk 8
set.seed(12345)
## Data set 1
n <- 200
p <- 400
X1 <- matrix(rnorm(n*p),n,p)
beta0 <- matrix(rnorm(p),p,1)
y1 <- (runif(n) <= plogis(X1%*%beta0)) + 0
lambda=10
fit.1.naive <- system.time(logistic_ridge_newton(X1, y1, beta0, lambda, method = "smw"))
## Data set 2
p <- 800
X2 <- matrix(rnorm(n*p),n,p)
beta0 <- matrix(rnorm(p),p,1)
y2 <- (runif(n) <= plogis(X2%*%beta0)) + 0
fit.2.naive <- system.time(logistic_ridge_newton(X2, y2, beta0, lambda, method = "naive"))
## Data set 3
p <- 1600
X3 <- matrix(rnorm(n*p),n,p)
beta0 <- matrix(rnorm(p),p,1)
y3 <- (runif(n) <= plogis(X3%*%beta0)) + 0
fit.3.naive <- system.time(logistic_ridge_newton(X3, y3, beta0, lambda, method = "naive"))
## Number of International Calls from Belgium,
## taken from the Belgian Statistical Survey,
## published by the Ministry of Economy,
##
## 73 subjects, 2 variables:
##  Year(x[i])
##  Number of Calls (y[i], in tens of millions)
##
## http://www.uni-koeln.de/themen/statistik/data/rousseeuw/
## Datasets used in Robust Regression and Outlier Detection (Rousseeuw and Leroy, 1986).
## Provided on-line at the University of Cologne.
rm(list=ls())  # clean up workspace
library(xji3ST790)
x <- c(50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
69, 70, 71, 72, 73)
y <- c(0.44, 0.47, 0.47, 0.59, 0.66, 0.73, 0.81, 0.88, 1.06, 1.20, 1.35, 1.49, 1.61,
2.12, 11.90, 12.40, 14.20, 15.90, 18.20, 21.20, 4.30, 2.40, 2.70, 2.90)
epsilon <- 0.25
X <- cbind(rep(1, length(x)), x)
fit.smLAD <- smLAD(X, y)
fit.lm <- lm(y ~ X)
fitted.lm <- fit.lm$fitted.values
fitted.smLAD <- X %*% fit.smLAD$beta
# Now plot the two fitted lines and data
plot(x, y, type = "l", col = "blue", main = "Step 2 plot")
lines(x, fitted.lm, lty = 2, col = "green")
lines(x, fitted.smLAD, lty = 3, col = "red")
legend(x[1], 20,legend = c("Data", "Least Sqaure", "smLAD"),
lty = c(1, 2, 3), col = c("blue", "green", "red"))
library(xji3ST790)
library(xji3ST790)
install.packages("rjags")
library(rjags)
load("/Users/xji3/Downloads/USHCNprcpSetup.RData")
year <- rep(1900:2014, each=365)
temp1 <- PRCP[which(year >= 1950), ]
temp <- PRCP[(50*365 + 1):(115*365), ]
# Construct Yit matrix first
Yit.missing <- NULL
Yit0 <- NULL
for(i in 1:(2014 - 1950 + 1)){
Yit.missing <- rbind(Yit.missing, colSums(is.na(temp[(365*(i-1) + 1):(365*i), ])))
Yit0 <- rbind(Yit0, apply(temp[(365*(i-1) + 1):(365*i), ], 2, max, na.rm = T))
}
Yit0[Yit.missing > 50] <- NA
dim(Yit.missing)
Yit.missing[1:10,1:10]
dim(Yit0)
# Column operations
Yit <- Yit0[, colSums(is.na(Yit0)) < 11]
dim(Yit)
hist(Yit)
Yit0[1, 1:5]
Yit0[1:4, 1:5]
dim(Yit)
Yit[1:4, 1:5]
install.packages("rjags")
library(rjags)
install.packages("rjags")
library(rjags)
###############################################################################################
####
#### ST590-640 Exam 3
#### Author: Yi Zhang
#### Date: May 5, 2017
####
###############################################################################################
rm(list=ls())
library(rjags)
#load("C:/Users/Wang Lab/Documents/NCSU/ST590-Applied Bayesian Analysis/2017Spring/Exams/E3/USHCNprcpSetup.RData")
load("/Users/xji3/Downloads/USHCNprcpSetup.RData")
year <- rep(1900:2014, each=365)
temp1 <- PRCP[which(year >= 1950), ]
temp <- PRCP[(50*365 + 1):(115*365), ]
# Construct Yit matrix first
Yit.missing <- NULL
Yit0 <- NULL
for(i in 1:(2014 - 1950 + 1)){
Yit.missing <- rbind(Yit.missing, colSums(is.na(temp[(365*(i-1) + 1):(365*i), ])))
Yit0 <- rbind(Yit0, apply(temp[(365*(i-1) + 1):(365*i), ], 2, max, na.rm = T))
}
Yit0[Yit.missing > 50] <- NA
dim(Yit.missing)
Yit.missing[1:10,1:10]
dim(Yit0)
# Column operations
Yit <- Yit0[, colSums(is.na(Yit0)) < 11]
dim(Yit)
hist(Yit)
max(Yit)
Ybar <- mean(Yit, na.rm = T)
#for(i in 1:ncol(Yit)){
#  Yit[is.na(Yit[,i]), i] <- round(Ybar)
#}
Yit[,1]
Yit[,2]
Yit[,3]
Yit[,4]
hist(Yit)
hist(log(Yit))
head(Yit)
ls()
plot(lon.lat,axes=FALSE,xlab="",ylab="",main="Monitor locations")
boxplot(Yit,xlab="Stations",ylab="Maximum daily Precipitation",main="Maximum daily Precipitation each year from 1950-2014 by stations")
boxplot(log(Yit),xlab="Stations",ylab="Log of maximum daily Precipitation",main="Log of maximum daily Precipitation each year from 1950-2014 by stations")
boxplot(t(log(Yit)),xlab="Year",ylab="Log of maximum daily Precipitation",main="Log of maximum daily Precipitation each year from 1950-2014 by year")
## JAGS model and convergence diagnostics
nt   <- nrow(Yit)
ns   <- ncol(Yit)
modelstring <- "model{
# Likelihood
for(i in 1:ns){
for(t in 1950:2014){
Yit[i,t] ~ dgamma(a[i, t],b[i,t])
a[i, t] <- (beta1[i] + X[t] * beta2[i])^2/beta3[i]
b[i, t] <- (beta1[i] + X[t] * beta2[i])/beta3[i]
X[t] <- (t-1950)/10
}
}
# Random effects
for(i in 1:ns){
beta1[i] ~ dnorm(0,tau1)
beta2[i] ~ dnorm(0,tau2)
beta3[i] ~ dnorm(0,tau3)
}
# Priors
tau1 ~ dgamma(0.1,0.1)
tau2 ~ dgamma(0.1,0.1)
tau3 ~ dgamma(0.1,0.1)
}"
dat    <- list(Y=log(Yit),ns=ns,nt=nt)
#init   <- list(RE=rep(0,ns))
#init   <- list(mu=Ybar)
model1 <- jags.model(textConnection(modelstring),data = dat, quiet=TRUE, n.chains=1)
finished.pairs <- readLines('../Filtered_pairs.txt')
read.summary.mat <- function(summary_file, col_names){
all <- readLines(summary_file, n = -1)
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col_names))
return (summary_mat)
}
rm(list=ls())  # clean up workspace
setwd("/Users/xji3/GitFolders/YeastIGCTract/PSJSAnalyses/")
filtered.pairs <- readLines('../Filtered_pairs.txt')
rm(list=ls())  # clean up workspace
setwd("/Users/xji3/GitFolders/YeastIGCTract/PSJSAnalyses/")
filtered.pairs <- readLines('../Filtered_pairs.txt')
# Now read in individual summary of gene pairs
PSJS.HKY.rv.nonclock.summary.guess.1 <- NULL
PSJS.HKY.rv.nonclock.summary.guess.2 <- NULL
for (pair in filtered.pairs){
summary.file.name <- paste("PSJS_HKY", pair, "One_rate_Guess_1_rv_SCOK_nonclock_summary.txt", sep = "_")
summary_file <- paste("./summary/", summary.file.name, sep = "")
all <- readLines(summary_file, n = -1)
col.names <- pair
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col.names))
PSJS.HKY.rv.nonclock.summary.guess.1 <- cbind(PSJS.HKY.rv.nonclock.summary.guess.1, summary_mat)
summary.file.name <- paste("PSJS_HKY", pair, "One_rate_Guess_2_rv_SCOK_nonclock_summary.txt", sep = "_")
summary_file <- paste("./summary/", summary.file.name, sep = "")
all <- readLines(summary_file, n = -1)
col.names <- pair
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col.names))
PSJS.HKY.rv.nonclock.summary.guess.2 <- cbind(PSJS.HKY.rv.nonclock.summary.guess.2, summary_mat)
#YER102W_YBL072C guess 2 file is a fake copy of guess 1 file
}
PSJS.HKY.rv.nonclock.summary.guess.1
summary.txt", sep = "_")
summary.file.name <- paste("PSJS_dim_1_HKY", pair, "One_rate_init_30.0_rv_SCOK_nonclock_summary.txt", sep = "_")
summary_file <- paste("./summary/", summary.file.name, sep = "")
all <- readLines(summary_file, n = -1)
col.names <- pair
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col.names))
rm(list=ls())  # clean up workspace
setwd("/Users/xji3/GitFolders/YeastIGCTract/PSJSAnalyses/")
filtered.pairs <- readLines('../Filtered_pairs.txt')
# Now read in individual summary of gene pairs
PSJS.HKY.rv.nonclock.summary.guess.1 <- NULL
PSJS.HKY.rv.nonclock.summary.guess.2 <- NULL
PSJS.HKY.rv.nonclock.summary.dim.1 <- NULL
for (pair in filtered.pairs){
summary.file.name <- paste("PSJS_HKY", pair, "One_rate_Guess_1_rv_SCOK_nonclock_summary.txt", sep = "_")
summary_file <- paste("./summary/", summary.file.name, sep = "")
all <- readLines(summary_file, n = -1)
col.names <- pair
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col.names))
PSJS.HKY.rv.nonclock.summary.guess.1 <- cbind(PSJS.HKY.rv.nonclock.summary.guess.1, summary_mat)
summary.file.name <- paste("PSJS_HKY", pair, "One_rate_Guess_2_rv_SCOK_nonclock_summary.txt", sep = "_")
summary_file <- paste("./summary/", summary.file.name, sep = "")
all <- readLines(summary_file, n = -1)
col.names <- pair
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col.names))
PSJS.HKY.rv.nonclock.summary.guess.2 <- cbind(PSJS.HKY.rv.nonclock.summary.guess.2, summary_mat)
summary.file.name <- paste("PSJS_dim_1_HKY", pair, "One_rate_init_30.0_rv_SCOK_nonclock_summary.txt", sep = "_")
summary_file <- paste("./summary/", summary.file.name, sep = "")
all <- readLines(summary_file, n = -1)
col.names <- pair
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(summary_file,
row.names = row.names,
col.names = col.names))
PSJS.HKY.rv.nonclock.summary.dim.1 <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1, summary_mat)
}
PSJS.HKY.rv.nonclock.summary.dim.1
cbind(PSJS.HKY.rv.nonclock.summary.dim.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.2["tract_length", ])
tract.length <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.2["tract_length", ])
colnames(tract.length) <- c("dim 1", "All 1", "All 2")
tract.length
tract.length <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.2["tract_length", ])
colnames(tract.length) <- c("dim 1", "All 1", "All 2")
tract.length
lnL <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["ll", ],
PSJS.HKY.rv.nonclock.summary.guess.1["ll", ],
PSJS.HKY.rv.nonclock.summary.guess.2["ll", ])
colnames(lnL)  <- c("dim 1", "All 1", "All 2")
lnL
cbind(tract.length, lnL)
tract.length <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.2["tract_length", ])
colnames(tract.length) <- c("dim 1 estimate", "All 1 estimate", "All 2 estimate")
lnL <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["ll", ],
PSJS.HKY.rv.nonclock.summary.guess.1["ll", ],
PSJS.HKY.rv.nonclock.summary.guess.2["ll", ])
colnames(lnL)  <- c("dim 1 lnL", "All 1 lnL", "All 2 lnL")
cbind(tract.length, lnL)
tract.length <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.1["tract_length", ],
PSJS.HKY.rv.nonclock.summary.guess.2["tract_length", ])
colnames(tract.length) <- c("dim 1 est", "All 1 est", "All 2 est")
lnL <- cbind(PSJS.HKY.rv.nonclock.summary.dim.1["ll", ],
PSJS.HKY.rv.nonclock.summary.guess.1["ll", ],
PSJS.HKY.rv.nonclock.summary.guess.2["ll", ])
colnames(lnL)  <- c("dim 1 lnL", "All 1 lnL", "All 2 lnL")
cbind(tract.length, lnL)
rm(list=ls())  # clean up workspace
setwd("/Users/xji3/GitFolders/YeastIGCTract/SimulationStudy/")
#setwd("/Users/Xiang/GitFolders/YeastIGCTract/SimulationStudy/")
Tract.list <- c(50.0)
guess.list <- c(50.0, 100.0, 250.0, 500.0)
# Now read in PSJS summary results
for(tract in Tract.list){
for(guess in guess.list){
PSJS.tract.summary <- NULL
for(sim in 1:100){
PSJS.summary <- paste("./summary/Tract_", toString(tract), '.0_HKY/sim_',
toString(sim), '/True_PSJS_HKY_rv_sim_',
toString(sim), "_Tract_", toString(tract), '.0_guess_',
toString(guess),'.0_nt_summary.txt', sep = "")
if (file.exists(PSJS.summary)){
all <- readLines(PSJS.summary, n = -1)
col.names <- paste("sim_", toString(sim), sep = "")
row.names <- strsplit(all[length(all)], ' ')[[1]][-1]
summary_mat <- as.matrix(read.table(PSJS.summary,
row.names = row.names,
col.names = col.names))
PSJS.tract.summary <- cbind(PSJS.tract.summary, summary_mat)
}
}
assign(paste("True_PSJS_HKY_Tract_", toString(tract), "_guess_",
toString(guess), "_summary", sep = ""), PSJS.tract.summary)
}
}
# Now combine all initial guess results
for(tract in Tract.list){
combined.PSJS.tract.summary <- NULL
col.list <- NULL
for ( sim_num in 1:100){
sim_col <- paste("sim_", toString(sim_num), sep = "")
best.lnL <- -Inf
best.guess <- NULL
for(guess in guess.list){
target_summary <- get(paste("True_PSJS_HKY_Tract_", toString(tract), "_guess_", toString(guess), "_summary", sep = ""))
if(sim_col %in% colnames(target_summary) ){
if (target_summary["ll", sim_col] > best.lnL){
best.lnL <- target_summary["ll", sim_col]
best.guess <- guess
}
}
}
if(! is.null(best.guess)){
combined.PSJS.tract.summary <- cbind(combined.PSJS.tract.summary,
get(paste("True_PSJS_HKY_Tract_", toString(tract), "_guess_", toString(best.guess), "_summary", sep = ""))[, sim_col])
col.list <- c(col.list, sim_col)
}
}
colnames(combined.PSJS.tract.summary) <- col.list
assign(paste("True_PSJS_HKY_Tract_", toString(tract), "_combined_summary", sep = ""), combined.PSJS.tract.summary)
}
True_PSJS_HKY_Tract_50_combined_summary
True_PSJS_HKY_Tract_50_combined_summary["tract_length", ]
mean(True_PSJS_HKY_Tract_50_combined_summary["tract_length", ])
Tract.list <- c(50.0)
for(tract in Tract.list){
target_summary <- get(paste("True_PSJS_HKY_Tract_", toString(tract), "_combined_summary", sep = ""))
col.names <- target_summary["tract_length", ] < 10*tract
sim_info <- get(paste("sim.tract.", toString(tract), sep = ""))
hist(target_summary["tract_length", col.names], breaks = 50,
main = paste("PSJS Estimated Tract length 1/p, Tract = ", toString(tract), ".0 ", sep = ""))
#abline(v =  realized.tract.dist(492, 1.0/tract)$mean, col = "blue")
abline(v =  tract, col = 2)
#abline(v =  mean(sim_info["mean subtract length", ]), col = "green")
}
Tract.list <- c(50.0)
for(tract in Tract.list){
target_summary <- get(paste("True_PSJS_HKY_Tract_", toString(tract), "_combined_summary", sep = ""))
col.names <- target_summary["tract_length", ] < 10*tract
#sim_info <- get(paste("sim.tract.", toString(tract), sep = ""))
hist(target_summary["tract_length", col.names], breaks = 50,
main = paste("PSJS Estimated Tract length 1/p, Tract = ", toString(tract), ".0 ", sep = ""))
#abline(v =  realized.tract.dist(492, 1.0/tract)$mean, col = "blue")
abline(v =  tract, col = 2)
#abline(v =  mean(sim_info["mean subtract length", ]), col = "green")
}
cat("Mean: ", mean(target_summary["tract_length", col.names]), " Number of datasets: ", length(col.names))
Tract.list <- c(50.0)
for(tract in Tract.list){
target_summary <- get(paste("True_PSJS_HKY_Tract_", toString(tract), "_combined_summary", sep = ""))
col.names <- target_summary["tract_length", ] < 10*tract
#sim_info <- get(paste("sim.tract.", toString(tract), sep = ""))
hist(target_summary["tract_length", col.names], breaks = 50,
main = paste("PSJS Estimated Tract length 1/p, Tract = ", toString(tract), ".0 ", sep = ""))
#abline(v =  realized.tract.dist(492, 1.0/tract)$mean, col = "blue")
abline(v =  tract, col = 2)
#abline(v =  mean(sim_info["mean subtract length", ]), col = "green")
cat(" Number of datasets: ", length(col.names), "\n Mean: ", mean(target_summary["tract_length", col.names]),
"sd: ", sd(target_summary["tract_length", col.names]))
}
Tract.list <- c(50.0)
for(tract in Tract.list){
target_summary <- get(paste("True_PSJS_HKY_Tract_", toString(tract), "_combined_summary", sep = ""))
col.names <- target_summary["tract_length", ] < 10*tract
#sim_info <- get(paste("sim.tract.", toString(tract), sep = ""))
hist(target_summary["tract_length", col.names], breaks = 50,
main = paste("PSJS Estimated Tract length 1/p, Tract = ", toString(tract), ".0 ", sep = ""))
#abline(v =  realized.tract.dist(492, 1.0/tract)$mean, col = "blue")
abline(v =  tract, col = 2)
#abline(v =  mean(sim_info["mean subtract length", ]), col = "green")
cat(" Number of datasets: ", length(col.names), "True Tract: ", tract, "\n Mean: ", mean(target_summary["tract_length", col.names]),
"sd: ", sd(target_summary["tract_length", col.names]))
}
cat(" Number of datasets: ", length(col.names), ". True Tract: ", tract, "\n Mean: ", mean(target_summary["tract_length", col.names]),
"sd: ", sd(target_summary["tract_length", col.names]))
